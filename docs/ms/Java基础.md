## **5种IO模型？**

> **关注消息通信机制：**
>
> **同步：调用一个功能，在功能结果没有返回之前，一直等待结果返回。**
>
> **异步：调用一个功能，调用立刻返回，但调用者不能立刻得到结果。调用者可以继续后续的操作，其结果一般通过状态，回调函数来通知调用者。**
>
> **等待调用结果时的状态：**
>
> **阻塞：调用一个函数，当调用结果返回之前，当前线程会被挂起，只有得到结果之后才会返回。**
>
> **非阻塞：调用一个函数，不能立刻得到结果之前，调用不能阻塞当前线程。**

> **一个输入操作通常包括两个阶段：**
>
> - **等待数据准备好**
> - **从内核向进程复制数据**
>
> **对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待数据到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。**

> 阻塞IO模型：应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回。
>
> 非阻塞IO模型：进程发起IO系统调用后，内核返回一个错误码而不会被阻塞；应用进程可以继续执行，但是需要不断的执行系统调用来获知 I/O 是否完成。如果内核缓冲区有数据，内核就会把数据返回进程。
>
> IO复用模型：使用 select 或者 poll 等待数据，可以等待多个套接字中的任何一个变为可读。这一过程会被阻塞，当某一个套接字可读时返回，之后把数据从内核复制到进程中。（在多路复用IO模型中，会有一个线程不断去轮询多个socket的状态，只有当socket真正有读写事件时，才真正调用实际的IO读写操作。因为在多路复用IO模型中，只需要使用一个线程就可以管理多个socket，并且只有在真正有socket读写事件进行时，才会使用IO资源，所以它大大减少了资源占用。）
>
> 信号驱动IO模型：当进程发起一个IO操作，会向内核注册一个信号处理函数，然后进程返回不阻塞；当内核数据就绪时会发送一个信号给进程，进程便在信号处理函数中调用IO读取数据。
>
> 异步IO模型：当进程发起一个IO操作，进程返回不阻塞，但也不能返回结果；内核把整个IO处理完后，会通知进程结果。如果IO操作成功则进程直接获取到数据。