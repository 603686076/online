## 介绍一下 Java 有哪些锁

(synchronized、juc 提供的锁如 ReentrantLock、CountDownLatch、CyclicBarrier、Semaphore等)

公平锁/非公平锁 (重要)

可重入锁

独享锁/共享锁 (重要)

互斥锁/读写锁

乐观锁/悲观锁 (重要)

偏向锁/轻量级锁/重量级锁 (重要)

自旋锁

### **公平锁/非公平锁**

公平锁是指多个线程按照申请锁的顺序来获取锁。

非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比 先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象。

对于Java ReentrantLock而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大。对于Synchronized而言，也是一种非公平锁。由于其并不像ReentrantLock是通过AQS的来实现线程调度，所以并没有任何办法 使其变成公平锁。

可重入锁

可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会 自动获取锁。

对于Java ReentrantLock而言，是一个可重入锁，其名字是Re entrant Lock重新进入锁。

对于Synchronized而言，也是一个可重入锁。可重入锁的一个好处是可一定程度避免死锁。

### **独享锁/共享锁 (互斥锁/读写锁)**

独享锁是指该锁一次只能被一个线程所持有。共享锁是指该锁可被多个线程所持有。

对于Java ReentrantLock而言，其是独享锁。但是对于Lock的另一个实现类ReadWriteLock，其读锁是共享锁，其写锁是独享锁。

上面讲的独享锁/共享锁就是一种广义的说法，互斥锁/读写锁就是具体的实现。 互斥锁在Java中的具体实现就是ReentrantLock

读写锁在Java中的具体实现就是ReadWriteLock

### **乐观锁/悲观锁**

乐观锁与悲观锁不是指具体的什么类型的锁，而是指看待并发同步的角度。

对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁的并发操作 一定会出问题。

乐观锁在更新数据的时候，主要就是两个步骤：冲突检测和数据更新。乐观的认为，不 加锁的并发操作是没有事情的。当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被 告知这次竞争中失败，并可以再次尝试。

从上面的描述我们可以看出，悲观锁适合写操作非常多的场景，乐观锁适合读操作非常 多的场景，不加锁会带来大量的性能提升。

悲观锁在Java中的使用，就是利用各种锁。

乐观锁在Java中的使用，是无锁编程，常常采用的是CAS算法，典型的例子就是原子 类，通过CAS自旋实现原子操作的更新。

CAS包含三个参数 CAS（V,E,N）。V表示要更新的变量，E表示预期的值，N表示新值。仅当要更新的变量值等于预期的值时，才会将要更新的变量值的值设置成新 值，否则什么都不做。

### **偏向锁/轻量级锁/重量级锁**

这三种锁是指锁的状态，并且是针对Synchronized。

偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取 锁的代价。

轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级 锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。

重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下 去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。 重量级锁会让其他申请的线程进入阻塞，性能降低。

自旋锁

自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样 的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。

## **乐观锁和悲观锁讲一下，哪些地方用到。**

> 乐观锁与悲观锁不是指具体的什么类型的锁，而是指**看待并发同步的角度**。 悲观锁对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁的并发操作一定会出问题。 乐观锁在更新数据的时候，会采用尝试更新，不断重试的方式更新数据。乐观的认为，不加锁的并发操作是没有事情的。
>
> **共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程**，传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁，数据库的for update SQL语句。Java中`synchronized`和`ReentrantLock`等独占锁就是悲观锁思想的实现。
>
> **乐观锁适用于多读的应用类型，这样可以提高吞吐量**。在Java中`java.util.concurrent.atomic`包下面的原子变量类就是使用了乐观锁的一种实现方式**CAS**实现的。
>
> **乐观锁适用于写比较少的情况下（多读场景）**，**一般多写的场景下用悲观锁就比较合适**，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能。