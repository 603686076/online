## **各种垃圾回收算法和回收器，说出自己的理解。**

> **垃圾回收算法**：标记-清除，标记-整理，复制，分代收集。
>
> **垃圾回收器**：新生代垃圾收集器：Serial，ParNew，Parallel Scanvenge。
>
> 老年代垃圾收集器：CMS，Serial Old，Parallel Old。
>
> 整堆收集器：G1；
>
> 除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。

> **Serial**：新生代，复制算法，单线程收集，必须暂停所有工作线程，直到完成。
>
> **ParNew**： ParNew垃圾收集器是Serial收集器的多线程版本。
>
> **Parallel Scavenge**：高吞吐量为目标，即减少垃圾收集时间，让用户代码获得更长的运行时间。
>
> **Serial Old**：Serial收集器的老年代版本，采用"标记-整理"算法。
>
> **Parallel Old**：Parallel Old垃圾收集器是Parallel Scavenge收集器的老年代版本。采用"标记-整理"算法。
>
> **CMS**：CMS 收集器是一种 **“标记-清除”算法**实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：
>
> 1. **初始标记**：仅标记一下GC Roots能直接关联到的对象；2. **并发标记**：进行 GC Roots Tracing 的过程，也就是从GC Roots开始找到它能引用的所有其它对象。3. **重新标记**：修正并发标记期间因用户程序继续运作而导致标记变动的那一部分对象的标记记录。4. **并发清除**：回收所有的垃圾对象， 开启用户线程， GC 线程开始对**未标记**的区域做清扫。
>
> - 并发阶段占用cpu资源，拖慢用户程序，降低吞吐量，CMS默认启用（CPU + 3)/4个线程执行。
> - 无法处理浮动垃圾，并发清理阶段用户程序产生的垃圾，成为浮动垃圾，无法被当次处理。
> - 基于标记-清除算法的CMS，会使老年代产生很多空间碎片，不利于大对象的使用
>
> **G1**：G1 可以直接对新生代和老年代一起回收。G1 把堆划分成多个大小相等的独立区域，维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 区域。
>
> 1. 初始标记。2. 并发标记。3. 最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录。4. 筛选回收：首先对各个区域中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。

> G1收集器的设计目标是取代CMS收集器，它同CMS相比，在以下方面表现的更出色：
>
> - G1是一个有**整理内存**过程的垃圾收集器，**不会产生很多内存碎片**。
> - CMS采用的是标记清除垃圾回收算法，可能会产生不少的内存碎片。
> - G1的Stop The World(STW)更可控，G1在停顿时间上添加了**预测机制**，用户可以**指定期望停顿时间**。